import { Chessboard } from "react-chessboard";
import { Chess, Color, Move } from "chess.js";
import { useEffect, useRef, useState } from "react";
import {
  Piece,
  PromotionPieceOption,
  Square,
} from "react-chessboard/dist/chessboard/types";
import { Socket } from "socket.io-client";

type VsPlayerProps = {
  socket: Socket;
  roomId: string;
  onLeave: () => void;
};

function VsPlayer({ socket, roomId, onLeave }: VsPlayerProps) {
  const savedGames = useRef<string[]>(
    JSON.parse(localStorage.getItem("vsPlayer") ?? "[]")
  );
  const playerName = useRef<string>(
    localStorage.getItem("player") ?? `ÏùµÎ™Ö-${socket.id}`
  );
  const game = useRef(new Chess());
  const myColor = useRef<string>(
    sessionStorage.getItem(`color-${roomId}`) || null
  );

  const [fen, setFen] = useState(game.current.fen());
  const [fromSquare, setFromSquare] = useState<Square | null>(null);
  const [toSquare, setToSquare] = useState<Square | null>(null);
  const [focusSquare, setFocusSquare] = useState({});
  const [possibleSquares, setPossibleSquares] = useState({});
  const [showPromotionDialog, setShowPromotionDialog] = useState(false);
  const [undoing, setUndoing] = useState(false);
  const undoingRef = useRef(false);

  const hasRun = useRef(false);
  useEffect(() => {
    if (hasRun.current) return;
    hasRun.current = true;
    // Ï¥àÍ∏∞ ÏÜåÏºì, Î∞© ÏÑ§Ï†ï
    initSocket();

    // Ï¥àÍ∏∞ Ìó§Îçî ÏÑ§Ï†ï
    game.current.setHeader("Event", "vsPlayer");
    game.current.setHeader("Site", "ChessTS");
    game.current.setHeader("Date", getCurrentDate());
    game.current.setHeader("Round", `${savedGames.current.length + 1}`);
  }, [socket]);

  useEffect(() => {
    if (fromSquare && toSquare) {
      const moves = game.current.moves({
        square: fromSquare,
        verbose: true,
      });
      const foundMove = moves.find(
        (m) => m.from === fromSquare && m.to === toSquare
      );
      if (foundMove) {
        // if promotion move
        if (
          (foundMove.color === "w" &&
            foundMove.piece === "p" &&
            toSquare[1] === "8") ||
          (foundMove.color === "b" &&
            foundMove.piece === "p" &&
            toSquare[1] === "1")
        ) {
          setShowPromotionDialog(true);
          return;
        }
      }
      try {
        game.current.move({
          from: fromSquare,
          to: toSquare,
          promotion: "q",
        });
        setFen(game.current.fen());
        playMoveSound();
        sendMove();
        checkWin();
      } catch (error) {
        console.log(error);
      } finally {
        setFromSquare(null);
        setToSquare(null);
        setPossibleSquares({});
      }
    }
  }, [fromSquare, toSquare]);

  /** socket io Ìï®Ïàò ============================================================================= */

  function initSocket() {
    // Î∞© ÏûÖÏû•
    socket.emit("join", roomId);

    // pgn Î°úÎìú
    socket.on("initGame", (pgn: string) => {
      try {
        game.current.loadPgn(pgn);
        setTimeout(() => {
          setFen(game.current.fen());
        }, 1000);
      } catch (err) {
        console.error("PGN Î°úÎìú Ïã§Ìå®:", err);
      }
    });

    // color ÌôïÏù∏
    socket.on("assignColor", (color: Color) => {
      if (myColor.current) return;
      myColor.current = color;
      sessionStorage.setItem(`color-${roomId}`, myColor.current);
      console.log("üé® ÎÇ¥ ÏÉâ:", myColor.current);
    });

    // ÏÉÅÎåÄ Ïàò ÏàòÏã†
    socket.on("move", (pgn: string) => {
      console.log("üì© ÏÉÅÎåÄ Ïàò ÏàòÏã†", pgn);
      try {
        game.current.loadPgn(pgn);
        setFen(game.current.fen());
        playMoveSound();
        setTimeout(() => {
          checkWin();
        }, 500);
      } catch (e) {
        console.error("ÏÉÅÎåÄ Ïàò ÏóêÎü¨", e);
      }
    });

    // ÎêòÎèåÎ¶¨Í∏∞ ÏàòÏã† ÏãúÏãú
    socket.on("undoRequest", () => {
      console.log("‚úÖ undoAccept Ïù¥Î≤§Ìä∏ ÏàòÏã†");
      const accept = confirm(
        "ÏÉÅÎåÄÍ∞Ä ÎêòÎèåÎ¶¨Í∏∞Î•º ÏöîÏ≤≠ÌñàÏäµÎãàÎã§. ÏàòÎùΩÌïòÏãúÍ≤†ÏäµÎãàÍπå?"
      );
      if (accept) {
        socket.emit("undoAccept", roomId);
        handleUndo(); // Î≥∏Ïù∏ÎèÑ Ï¶âÏãú ÎêòÎèåÎ¶¨Í∏∞
      } else {
        socket.emit("undoReject", roomId);
      }
    });

    // ÎêòÎèåÎ¶¨Í∏∞ ÏàòÎùΩ
    socket.on("undoAccept", () => {
      console.log("‚úÖ undoAccept Ïù¥Î≤§Ìä∏ ÏàòÏã†");
      handleUndo(); // ÎÇòÎèÑ ÎêòÎèåÎ¶¨Í∏∞
      setUndoing(false);
      undoingRef.current = false;
      alert("ÏÉÅÎåÄÍ∞Ä ÎêòÎèåÎ¶¨Í∏∞Î•º ÏàòÎùΩÌñàÏäµÎãàÎã§.");
    });

    // ÎêòÎèåÎ¶¨Í∏∞ Í±∞Ï†à
    socket.on("undoReject", () => {
      setUndoing(false);
      undoingRef.current = false;
      alert("ÏÉÅÎåÄÍ∞Ä ÎêòÎèåÎ¶¨Í∏∞Î•º Í±∞Ï†àÌñàÏäµÎãàÎã§.");
    });

    console.log("‚úÖ ÏÜåÏºì Ïó∞Í≤∞ ÏôÑÎ£å");
    return () => {
      socket.off("initGame");
      socket.off("assignColor");
      socket.off("move");
      socket.off("undoRequest");
      socket.off("undoAccept");
      socket.off("undoReject");
    };
  }

  // Í∏∞Î¨º Ïù¥Îèô ÏöîÏ≤≠
  function sendMove() {
    setColorHearder();
    const pgn = game.current.pgn();
    socket.emit("move", {
      roomId: roomId,
      pgn,
    });
  }

  function setColorHearder() {
    myColor.current === "w"
      ? game.current.setHeader("White", playerName.current)
      : game.current.setHeader("Black", playerName.current);
  }

  // Î∞© ÎÇòÍ∞ÄÍ∏∞
  function leaveRoom() {
    game.current = new Chess();
    socket.emit("leave", roomId);
    onLeave();
  }

  /** Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ Ìï®Ïàò =========================================================================== */

  function sendUndoRequest() {
    undoingRef.current = true;
    setUndoing(true);
    socket.emit("undoRequest", roomId);
  }

  const handleUndo = () => {
    game.current.undo();
    game.current.undo();
    setFen(game.current.fen()); // Îã§Ïãú Í∑∏Î†§ÏßÄÍ≤å
  };

  function getCurrentDate(): string {
    const now = new Date();

    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0"); // ÏõîÏùÄ 0Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎØÄÎ°ú +1
    const day = String(now.getDate()).padStart(2, "0");

    return `${year}.${month}.${day}`;
  }

  function checkGame(): string | boolean {
    if (game.current.isGameOver()) {
      if (game.current.isDraw()) {
        return "1/2-1/2";
      }
      if (game.current.turn() === "b") {
        // Ïàò ÎëêÍ≥† ÌÑ¥ ÎÑòÏñ¥Í∞ê
        return "1-0";
      } else {
        return "0-1";
      }
    }
    return false;
  }

  function checkWin() {
    const isEnd: boolean | string = checkGame();
    if (!isEnd) return;
    game.current.setHeader("Result", isEnd as string);
    if (isEnd === "1-0") {
      alert("Ìù∞ÏÉâ ÏäπÎ¶¨!");
    } else if (isEnd === "0-1") {
      alert("Í≤ÄÏ†ïÏÉâ ÏäπÎ¶¨!");
    } else {
      alert("Î¨¥ÏäπÎ∂Ä!");
    }
    saveLog();
    game.current.setHeader("Round", `${savedGames.current.length + 1}`);
  }

  function saveLog() {
    const pgn = game.current.pgn();
    savedGames.current.push(pgn);
    localStorage.setItem("vsPlayer", JSON.stringify(savedGames.current));
  }

  function playMoveSound() {
    const audio = new Audio(`${import.meta.env.BASE_URL}move.mp3`);
    audio.volume = 0.8;
    audio.play();
  }

  /** board Ìï®Ïàò============================================================================= */

  function onSquareClick(square: Square, piece: Piece | undefined) {
    if (undoingRef.current || game.current.turn() !== myColor.current) return;
    const colors: { [key: string]: { background: string } } = {};
    colors[square] = { background: "rgba(255, 255, 0, 0.4)" };
    if (piece && !fromSquare) {
      setPossibleSquares(colors);
      setFromSquare(square);
      return;
    }
    if (fromSquare && !toSquare) {
      setToSquare(square);
    }
  }

  function onPromotionPieceSelect(piece: PromotionPieceOption | undefined) {
    if (piece && fromSquare && toSquare) {
      game.current.move({
        from: fromSquare,
        to: toSquare,
        promotion: piece[1].toLowerCase() ?? "q",
      });
      setFen(game.current.fen());
      playMoveSound();
      sendMove();
      checkWin();
    }
    setShowPromotionDialog(false);
    setFromSquare(null);
    setToSquare(null);
    setPossibleSquares({});
    return true;
  }

  function colorSquares(square: Square | null) {
    if (!square) {
      setFocusSquare({});
      return;
    }
    const colors: { [key: string]: { background: string } } = {};
    const possibleMoves = game.current.moves({ square, verbose: true });
    for (const square of possibleMoves) {
      if (
        game.current.get(square.to) &&
        game.current.get(square.to)?.color !==
          game.current.get(square.from)?.color
      ) {
        colors[square.to] = {
          background:
            "radial-gradient(circle, rgba(0,0,0,.2) 65%, transparent 70%)",
        };
      } else {
        colors[square.to] = {
          background:
            "radial-gradient(circle, rgba(0,0,0,.2) 25%, transparent 30%)",
        };
      }
    }

    setFocusSquare(colors);
  }

  function isDraggablePiece({ piece }: { piece: Piece }) {
    return (
      !undoingRef.current &&
      game.current.turn() === myColor.current &&
      piece.startsWith(myColor.current)
    );
  }

  function onMouseOverSquare(square: Square) {
    colorSquares(square);
  }

  function onMouseOutSquare() {
    colorSquares(null);
  }

  function onPieceDrop(
    sourceSquare: Square,
    targetSquare: Square,
    piece: Piece
  ): boolean {
    let move: Move | boolean = false;
    try {
      move = game.current.move({
        from: sourceSquare,
        to: targetSquare,
        promotion: piece[1].toLowerCase() ?? "q",
      });
      setFen(game.current.fen());
      playMoveSound();
      sendMove();
      checkWin();
    } catch (error) {
      console.error(error);
    } finally {
      setFromSquare(null);
      setToSquare(null);
      setPossibleSquares({});
    }
    return move ? true : false;
  }
  return (
    <div>
      <h2 style={{ marginTop: "0px" }}>üÜö Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥ÏôÄ 1:1 Ï≤¥Ïä§ Í≤åÏûÑ</h2>

      {/* Ï≤¥Ïä§Ìåê Ïª®ÌÖåÏù¥ÎÑà */}
      <div className="board">
        <Chessboard
          position={fen}
          onSquareClick={onSquareClick}
          onMouseOverSquare={onMouseOverSquare}
          onMouseOutSquare={onMouseOutSquare}
          onPieceDrop={onPieceDrop}
          isDraggablePiece={isDraggablePiece}
          onPromotionPieceSelect={onPromotionPieceSelect}
          showPromotionDialog={showPromotionDialog}
          promotionToSquare={toSquare}
          boardOrientation={
            myColor.current === "w" || !myColor.current ? "white" : "black"
          }
          customBoardStyle={{
            borderRadius: "4px",
            boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.5)",
          }}
          customSquareStyles={{
            ...focusSquare,
            ...possibleSquares,
          }}
        ></Chessboard>
      </div>
      {/* Ïª®Ìä∏Î°§ Ìå®ÎÑê */}
      <div className="mt-6">
        <div className="flex justify-evenly">
          <button
            onClick={leaveRoom}
            className="bg-red-500 hover:bg-red-700 text-white text-md py-2 px-4 rounded-md"
          >
            üîô Î∞© ÎÇòÍ∞ÄÍ∏∞
          </button>
          {!undoing ? (
            <button
              className="bg-amber-400 text-white text-md py-2 px-4 rounded-md hover:bg-amber-600"
              onClick={sendUndoRequest}
            >
              <span>ÎêòÎèåÎ¶¨Í∏∞</span>
            </button>
          ) : (
            <button className="bg-amber-600 text-white text-md py-2 px-4 rounded-md hover:bg-amber-600">
              <span>ÎêòÎèåÎ¶¨Í∏∞ Ï§ë</span>
            </button>
          )}
        </div>
      </div>
    </div>
  );
}

export default VsPlayer;
